import s from"ioredis";import*as e from"crypto";import{EventEmitter as t}from"events";import{createRequire as i}from"node:module";function n(s){return`Minified Redux error #${s}; visit https://redux.js.org/Errors?code=${s} for the full message or use the non-minified dev environment for full errors. `}class o extends t{_maxListeners=10;_handlers={};_globalHandlers=[];addListener=(s,e)=>{if(Object.keys(this._handlers).length===this._maxListeners)throw Error(n(1));return this._handlers[s]=this._handlers[s]||[],this._handlers[s].push(e),this};addGlobalListener=s=>(this._globalHandlers.push(s),this);removeGlobalListener=s=>(this._globalHandlers=this._globalHandlers.filter((e=>e===s)),this);once=(s,e)=>{if(Object.keys(this._handlers).length===this._maxListeners)throw Error(n(1));this._handlers[s]=this._handlers[s]||[];const t=(...i)=>{e(...i),this.off(s,t)};return this._handlers[s].push(t),this};removeListener=(s,e)=>(this._handlers[s]&&(this._handlers[s]=this._handlers[s].filter((s=>s!==e))),this);off=(s,e)=>this.removeListener(s,e);removeAllListeners=s=>(s?delete this._handlers[s]:(this._handlers={},this._globalHandlers=[]),this);setMaxListeners=s=>(this._maxListeners=s,this);getMaxListeners=()=>this._maxListeners;listeners=s=>this._handlers[s]?[...this._handlers[s]]:[];rawListeners=s=>[...this._handlers[s]];listenerCount=s=>this._handlers[s]?Object.keys(this._handlers[s]).length:0;prependListener=(s,e)=>{if(Object.keys(this._handlers).length===this._maxListeners)throw Error(n(1));return this._handlers[s]=this._handlers[s]||[],this._handlers[s].unshift(e),this};prependOnceListener=(s,e)=>{if(Object.keys(this._handlers).length===this._maxListeners)throw Error(n(1));this._handlers[s]=this._handlers[s]||[];const t=(...i)=>{e(...i),this.off(s,t)};return this._handlers[s].unshift(t),this};eventNames=()=>Object.keys(this._handlers);on=(s,e)=>this.addListener(s,e);emit=(s,...e)=>{const t=this.listeners(s);return t.length>0?(t.forEach((s=>s(e))),!0):(this._globalHandlers.forEach((t=>t(s,e))),!1)}}const r=s=>Buffer.from(JSON.stringify(s));class h extends o{_id;_ws;_fnId=0;_acks=new Map;_maxListeners=50;_debug;_closed=!1;_handlers={};get id(){return this._id}get ws(){return this._ws}constructor(s,e,t){super(),this._id=s,this._ws=e,this._debug=t}join=s=>(this._debug&&console.log(`${this._id} joining group ${s}`),this._ws.subscribe(s),this);leave=s=>(this._debug&&console.log(`${this._id} left group ${s}`),this._ws.unsubscribe(s),this);send=(...s)=>(s.unshift("message"),this._send({type:0,data:s}));isClosed=()=>this._closed;emit=(s,...e)=>{e.unshift(s);const t={type:0,data:e};return"function"==typeof e[e.length-1]&&(this._acks.set(this._fnId,e.pop()),t.id=this._fnId,this._fnId+=1),this._send(t)};_send=s=>(this._debug&&console.log(`Sending packet to ${this._id}:  ${JSON.stringify(s.data)}`),!this._closed&&2!==this._ws.send(r(s)));_ack=s=>{let e=!1;return(...t)=>{e||(this._send({type:1,data:t,id:s}),e=!0)}};onMessage=s=>{try{const e=(s=>{const e=""+Buffer.from(s);try{return JSON.parse(e)}catch(s){throw Error(n(2))}})(s);if(this._debug&&console.log(`Got packet from ${this._id}: ${JSON.stringify(e.data)}`),0===e.type){const s=e.data[0];if(this._handlers[s]){const t=e.data.slice(1);void 0!==e.id&&t.push(this._ack(e.id));try{this._handlers[s].forEach((s=>s(...t)))}catch(s){console.error(s)}}}else if(1===e.type&&void 0!==e.id){const s=this._acks.get(e.id);"function"==typeof s&&(s.apply(this,e.data),this._acks.delete(e.id))}else console.error("Unknown packet: "+e.type)}catch(s){console.error(s)}};onDisconnect=()=>{this._debug&&console.log(`Client ${this._id} disconnected`),this._closed=!0,this._handlers.disconnect&&this._handlers.disconnect.forEach((s=>s()))};error=s=>this.emit("error",s);disconnect=()=>(this._debug&&console.log("Disconnecting "+this._id),this._ws.close(),this._closed=!0,this);getUserData=s=>this._ws[s]}const c=i(import.meta.url);var l;!function(s){s[s.LIBUS_LISTEN_DEFAULT=0]="LIBUS_LISTEN_DEFAULT",s[s.LIBUS_LISTEN_EXCLUSIVE_PORT=1]="LIBUS_LISTEN_EXCLUSIVE_PORT"}(l||(l={}));const a=(()=>{try{const s=`../bin/uws_${process.platform}_${process.arch}_${process.versions.modules}.node`;return c(s)}catch(s){throw Error(n(0))}})(),d=25e3,_=5e3;class u{_app;_options;_pub;_sub;_connections={};_handler;constructor(t,i){this._app=t,this._options={redisUrl:i?.redisUrl||void 0,pingInterval:i?.pingInterval||d,pingTimeout:i?.pingInterval||_,debug:i?.debug};const{redisUrl:n}=this._options;n&&(this._options.debug&&console.log("Using REDIS at "+n),this._pub=new s(n),this._sub=new s(n),this._sub.subscribe("a",(s=>s&&console.error(s.message))),this._sub.on("messageBuffer",((s,e)=>{this._options.debug&&console.log("Publishing message from REDIS to all"),this._app.publish("a",e)})),this._sub.psubscribe("g.*","d.*",(s=>s&&console.error(s.message))),this._sub.on("pmessageBuffer",((s,e,t)=>{const i=""+e,n=i.charAt(0),o=i.substring(2);"d"===n?(this._options.debug&&console.log(`Disconnecting everybody in group ${o} due to message from REDIS`),this._disconnectGroup(o)):"g"===n&&(this._options.debug&&console.log("Publishing message from REDIS to group "+o),this._app.publish(o,t))}))),this._app.ws("/*",{compression:a.SHARED_DECOMPRESSOR,maxPayloadLength:16777216,idleTimeout:0,maxBackpressure:1024,open:s=>{const t=e.randomBytes(16).toString("hex");if(s.subscribe("a"),s.id=t,s.alive=!0,this._connections[t]=new h(t,s,i?.debug),this._handler)try{this._handler(this._connections[t])}catch(s){console.error(s)}},pong:s=>{s.alive=!0},message:(s,e)=>{const t=s.id;this._connections[t]?this._connections[t].onMessage(e):console.error("Got message from unknown connection: "+t)},drain:s=>{i?.debug&&console.log("Drain: "+s.id)},close:s=>{const e=s.id;this._connections[e]&&(this._options.debug&&console.log(`Client ${e} disconnected, removing from registry`),this._connections[e].onDisconnect(),delete this._connections[e])}}),this._keepAliveSockets()}_keepAliveSockets=()=>{setTimeout((s=>{Object.keys(s).forEach((s=>{const{ws:e}=this._connections[s];e.alive?(e.alive=!1,e.ping("hey")):(this._options.debug&&console.log(`Ping pong timeout for ${s}, disconnecting client...`),this._connections[s].disconnect())})),this._keepAliveSockets()}),this._options.pingInterval,this._connections)};_disconnectGroup=s=>{Object.values(this._connections).forEach((e=>{e.ws.isSubscribed(s)&&e.disconnect()}))};onConnection=s=>(this._handler=s,this);toAll=(s,...e)=>{e.unshift(s);const t=r({type:0,data:e});return this._pub?this._pub.publish("a",t).catch((s=>console.error(s))):(this._options.debug&&console.log(`Publishing event ${s} to all`),this._app.publish("a",t)),this};to=(s,e,...t)=>{t.unshift(e);const i=r({type:0,data:t});return this._pub?this._pub.publish("g."+s,i).catch((s=>console.error(s))):(this._options.debug&&console.log(`Publishing event ${e} to group ${s}`),this._app.publish(s,i)),this};disconnect(s){return this._pub?this._pub.publish("d."+s,"").catch((s=>console.error(s))):(this._options.debug&&console.log("Disconnecting whole group "+s),this._disconnectGroup(s)),this}listen=s=>new Promise(((e,t)=>{this._app.listen(s,(i=>i?e(this):t(Error("Could not listen on port "+s))))}))}class p extends u{constructor(s,e,t){super(s,t),this.onConnection((s=>{s.once("token",(({token:t,...i})=>{if(!t||"string"!=typeof t)return s.disconnect();Promise.resolve(e(t,i)).then((e=>e?s.emit("ready"):s.disconnect())).catch((()=>s.disconnect()))}))}))}}export{l as ListenOptions,u as UWSProvider,p as UWSProviderWithToken,h as UWSSocket,a as uws};
